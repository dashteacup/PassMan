package cs242.pcurry2.pm;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.security.spec.KeySpec;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Class for password management functionality.
 */
public class PasswordManager {

    /**
     * Number of times to hash the password in {@link PBEKeySpec}.
     */
    private static final int iterations = 6000;

    /**
     * Length of the key to be generated by {@link PBEKeySpec}.
     */
    private static final int keyLength = 256;

    /**
     * Algorithm to be used with the JCA's PBE functionality.
     */
    private static final String pbeAlgorithm = "PBKDF2WithHmacSHA1";

    /**
     * Symmetric encryption algorithm used on password files.
     */
    private static final String encryptionAlgorithm = "AES";

    /**
     * Size of blocks used for encryption (and the headers/iv/salt) in bytes.
     */
    private static final int blockSize = 16;

    /**
     * Cryptographic transformation code used to encrypt the file data.
     */
    private static final String cipherTransformation = "AES/CBC/PKCS5PADDING";

    /**
     * Header for all .pman files so the program can identify if this is a
     * proper password database. Should always be 16 characters long.
     */
    private static final String passwordFileHeader = "PMFileVer001.000";

    /**
     * Header marking the beginning of the .pman file's encrypted content.
     * Should always be 16 characters long.
     */
    private static final String cipherTextHeader = "PMBeginCipherTxt";

    /**
     * Footer for all .pman files so the program can identify the valid
     * end of the file and know the data isn't corrupted. The program
     * should still make sure that it is the actual EOF after this text.
     * Any more text is an invalid .pman file. Should always be 16
     * characters long.
     */
    private static final String passwordFileFooter = "PMFileEndCipherT";

    /**
     * Unencrypted user data of a password file.
     * TODO: Currently I'm not worrying about keeping the file contents
     * encrypted in memory. I may change that in the future for enhanced
     * security.
     */
    private String currentFileText;

    /**
     * Salt for the current password file.
     */
    private byte[] currentFileSalt;

    /**
     * Initialization vector for the current password file.
     */
    private byte[] currentFileIV;

    /**
     * Constructor for the password manager.
     */
    public PasswordManager() {
        currentFileText = "";
        currentFileSalt = null;
        currentFileIV = null;
    }

    /**
     * Constructor with text data to be stored in the file.
     * @param content of the file to be encrypted
     */
    public PasswordManager(String content) {
        currentFileText = content;
        generateSalt();
    }

    /**
     * Testing constructor (not intended to be called by the App)
     * @param contents to be encrypted
     * @param salt salt added to pw used to encrypt the file
     * @param iv used for the CBC of this file
     */
    public PasswordManager(String contents, String salt, String iv) {
        currentFileText = contents;
        currentFileSalt = salt.getBytes();
        if (currentFileSalt.length != blockSize) {
            throw new IllegalArgumentException("Salt must be 16 bytes long.");
        }
        currentFileIV = iv.getBytes();
        if (currentFileIV.length != blockSize) {
            throw new IllegalArgumentException("IV must be 16 bytes long.");
        }
    }

    /**
     * Save a password file to disk.
     * @param fileName of file to be written
     * @param password used to encrypt the file. The password array will be
     * cleared by this method.
     * @throws IOException if there's an error while writing the file.
     */
    public void savePasswordFile(String fileName, char[] password)
            throws IOException {
        byte[] encrypted = encryptContent(currentFileText, password);
        Path file = Paths.get(fileName);

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        out.write(passwordFileHeader.getBytes());
        out.write(currentFileSalt);
        out.write(currentFileIV);
        out.write(cipherTextHeader.getBytes());
        out.write(encrypted);
        out.write(passwordFileFooter.getBytes());

        // Will overwrite an existing file.
        Files.write(file, out.toByteArray());
    }

    /**
     * Encrypt text using password basd encryption (PBE).
     * @param content to be encrypted
     * @param password to use to encrypt the text. The password array will be
     * cleared by this method.
     * @return the encrypted text
     */
    public byte[] encryptContent(String content, char[] password) {
        if (currentFileSalt == null) {
            generateSalt();
        }
        KeySpec baseKey = new PBEKeySpec(password, currentFileSalt, iterations, keyLength);
        clearPasswordArray(password);
        byte[] cipherText = null;
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(pbeAlgorithm);
            SecretKey secret = factory.generateSecret(baseKey);
            SecretKeySpec key = new SecretKeySpec(secret.getEncoded(), encryptionAlgorithm);
            Cipher encryptor = Cipher.getInstance(cipherTransformation);
            if (currentFileIV == null) {
                encryptor.init(Cipher.ENCRYPT_MODE, key);
                currentFileIV = encryptor.getIV();
            }
            else {
                encryptor.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(currentFileIV));
            }
            cipherText = encryptor.doFinal(content.getBytes());
        }
        catch (GeneralSecurityException e) {
            e.printStackTrace();
            System.exit(PMExitCode.JCA_ALGORITHM_ERROR);
        }
        return cipherText;

    }

    /**
     * Encrypt the current file's contents with password based encryption (PBE)
     * @param password to use to encrypt the text
     * @return the encrypted text
     */
    public byte[] encryptContent(char[] password) {
        return encryptContent(currentFileText, password);
    }

    /**
     * Open a password file and load its data into the PasswordManager.
     * @param file object representing the password file.
     * @param password used to encrypt the file.
     * @throws InvalidPasswordFileException when the file is improperly formatted.
     * @throws BadPasswordException when the user inputs an invalid password.
     * @throws IOException when there is a problem with reading the password file.
     */
    public void openPasswordFile(File file, char[] password)
            throws InvalidPasswordFileException, BadPasswordException, IOException {
        byte[] rawFileData = Files.readAllBytes(file.toPath());

        // Mark the locations of each component
        int fileHeaderStart = 0 * blockSize;
        int saltStart = 1 * blockSize;
        int ivStart = 2 * blockSize;
        int cipherHeaderStart = 3 * blockSize;
        int cipherTextStart = 4 * blockSize;
        int footerStart = rawFileData.length - blockSize;

        // Verify that the file has the appropriate structure
        if (rawFileData.length < 6 * blockSize) {
            throw new InvalidPasswordFileException("File is too small to be a valid .pman file");
        }
        String givenHeader = new String(Arrays.copyOfRange(
                rawFileData, fileHeaderStart, fileHeaderStart + blockSize));
        if (!passwordFileHeader.equals(givenHeader)) {
            throw new InvalidPasswordFileException("Invalid file header field.");
        }
        String givenCipherHeader = new String(Arrays.copyOfRange(
                rawFileData, cipherHeaderStart, cipherHeaderStart + blockSize));
        if (!cipherTextHeader.equals(givenCipherHeader)) {
            throw new InvalidPasswordFileException("Invalid cipher text header field.");
        }
        String givenFooter = new String(Arrays.copyOfRange(
                rawFileData, footerStart, footerStart + blockSize));
        if (!passwordFileFooter.equals(givenFooter)) {
            throw new InvalidPasswordFileException("Invalid file footer field.");
        }

        currentFileSalt = Arrays.copyOfRange(rawFileData, saltStart, saltStart + blockSize);
        currentFileIV = Arrays.copyOfRange(rawFileData, ivStart, ivStart + blockSize);
        byte[] cipherText = Arrays.copyOfRange(rawFileData, cipherTextStart, footerStart);
        byte[] decryptedText = decryptText(cipherText, password);
        currentFileText = new String(decryptedText);
    }

    /**
     * Open a password file and load its data into the PasswordManager.
     * @param file object representing the password file.
     * @param password used to encrypt the file.
     * @throws InvalidPasswordFileException when the file is improperly formatted.
     * @throws BadPasswordException when the user inputs an invalid password.
     * @throws IOException when there is a problem with reading the password file.
     */
    public void openPasswordFile(String filename, char[] password)
            throws InvalidPasswordFileException, BadPasswordException, IOException {
        // Interface convenience.
        openPasswordFile(new File(filename), password);
    }

    /**
     * Decrypt some cipher text with a given password.
     * @param cipherText encrypted data
     * @param password used to decrypt the cipherText. This password array will
     * be cleared by this method.
     * @return plain text result
     * @throws BadPasswordException when given an invalid password
     */
    public byte[] decryptText(byte[] cipherText, char[] password)
            throws BadPasswordException {
        if (currentFileIV == null || currentFileSalt == null) {
            throw new IllegalArgumentException("The current PM instance does not have a salt/iv");
        }
        KeySpec baseKey = new PBEKeySpec(password, currentFileSalt, iterations, keyLength);
        clearPasswordArray(password);
        byte[] plainText = null;
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(pbeAlgorithm);
            SecretKey secret = factory.generateSecret(baseKey);
            SecretKeySpec key = new SecretKeySpec(secret.getEncoded(), encryptionAlgorithm);
            Cipher decryptor = Cipher.getInstance(cipherTransformation);
            decryptor.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(currentFileIV));
            plainText = decryptor.doFinal(cipherText);
        }
        catch (BadPaddingException e) {
            // Almost certainly an invalid password. See:
            // http://stackoverflow.com/questions/8049872/given-final-block-not-properly-padded
            throw new BadPasswordException();
        }
        catch (GeneralSecurityException e) {
            e.printStackTrace();
            System.exit(PMExitCode.JCA_ALGORITHM_ERROR);
        }
        return plainText;
    }

    /**
     * Get the user made text of the currently loaded file.
     * @return user's data
     */
    public String getText() {
        return currentFileText;
    }

    /**
     * Set this PM's user data to a given String value.
     * @param newText the user's text data.
     */
    public void setText(String newText) {
        currentFileText = newText;
    }

    /**
     * Randomly generates a new 16 byte salt for this password manager.
     */
    private void generateSalt() {
        SecureRandom rand = new SecureRandom();
        byte[] salt = new byte[blockSize];
        rand.nextBytes(salt);
        currentFileSalt = salt;
    }

    /**
     * Fills a character array containing a password to prevent potential
     * exploits that may gain access to the password. This method should be
     * used the instant a password is no longer needed in memory.
     * @param password the password to be cleared from memory.
     */
    private void clearPasswordArray(char[] password) {
        Arrays.fill(password, '0');
    }
}
